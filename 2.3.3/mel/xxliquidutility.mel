global int $g_IndentNum = 0;
global int $g_ShowAELog = 1;
global int $g_ShowliqLog = 1;/*don't forget to update the "showMelCallStack"'s default value in liqGlobalsNode.cpp*/

global int $g_LogFileId = 0;
global string $g_LogFileFullPath="d:/liquidDebug.log";
global proc openLogFile()
{
	global int $g_LogFileId;
    global string $g_LogFileFullPath;
	
	$g_LogFileId=`fopen $g_LogFileFullPath "w"`;
	if($g_LogFileId == 0){
		error ("open "+$g_LogFileFullPath+" fail.");
	}
}
global proc closeLogFile()
{
	global int $g_LogFileId;
	fclose $g_LogFileId;
	$g_LogFileId = 0;
}

proc log2(string $prefix, string $log)
{
	global int $g_IndentNum;
	global int $g_LogFileId;

	string $indent;
	int $i=0;
	for(; $i<$g_IndentNum; ++$i){
		$indent +="    ";
	}

	if( $g_LogFileId == 0 ){// log file is not open.
		print($indent + $prefix +">"+ $log +"\n");
	}else{
		fprint $g_LogFileId ($indent + $prefix +">"+ $log +"\n");
	}


}
proc _liqError(string $prefix, string $log)
{
	global int $g_IndentNum;
	global int $g_LogFileId;

	string $indent;
	int $i=0;
	for(; $i<$g_IndentNum; ++$i){
		$indent +="    ";
	}

	if( $g_LogFileId == 0 ){// log file is not open.
		print($indent + $prefix +">"+ $log +"\n");
		error("liq error.\n");
	}else{
		fprint $g_LogFileId ($indent + $prefix +">"+ $log +"\n");
	}


}
global proc liqlog(string $log)
{
	global int $g_ShowliqLog;
	if( $g_ShowliqLog != 0 ){//$g_ShowliqLog is updated in liquidUpdateShowliqlog()
		log2("", $log);
	}
}

global proc liqDebug(string $log)
{
	log2("DEBUG", $log);
}
global proc liqError(string $log)
{
	_liqError("ERROR", $log);
}
global proc liqWarn(string $log)
{
	log2("WARNNING", $log);
}
global proc liqTrace(string $log)
{
	trace($log);
}
global proc liqAssert(int $condition, string $msg)
{
	if($condition == false){
		warning ($msg +"\n");
		confirmDialog 
			-title "liqAssert" 
			-message $msg
			-button        "Yes" 
			-defaultButton "Yes"
			-cancelButton  "Yes" 
			-dismissString "Yes";
	}
}

global proc liqPushIdent()
{
	global int $g_IndentNum;
	$g_IndentNum++;
}
global proc liqPopIdent()
{
	global int $g_IndentNum;
	$g_IndentNum--;
}

global proc liqAElog(string $log)
{
	global int $g_ShowAELog;

	if($g_ShowAELog){
		log2("", $log);
	}
}
//
global proc string xxu_getSingletonNode(string $type)
{
	liqPushIdent();
	liqlog("xxu_getSingletonNode("+$type+")");

	string $instance = $type +"1";
	if(`objExists $instance`==0)
	{
		liqlog("createNode "+$type+":"+$instance+"\n");
		$instance = `createNode $type`;
	}else{
		liqlog($instance +" already exists.\n");
	}

	liqPopIdent();	
	return $instance;
}
//
global proc string xxu_getSingletonNode2(string $type, string $name)
{	
	liqPushIdent();
	liqlog("xxu_getSingletonNode2("+$type+","+$name+")");

	if(`objExists $name`==0)
	{
		$instance = `createNode $type -n $name`;
	}
	liqPopIdent();	
	return $name;
}
//
global proc xxu_assertmy(int $condition, string $msg)
{
	if($condition == false){
		liqWarn($msg +"\n");
	}
}
//
global proc string[] xxu_getShapes( string $xform )
{
	liqPushIdent();
	liqlog("xxu_getShapes("+$xform+")");

   string $shapes[];

   $shapes[0] = $xform;

   if ( "transform" == `nodeType $xform` )
   // If given node is not a transform, assume it is a shape
   // and pass it through
   {
      $shapes = `listRelatives -fullPath -shapes -ni $xform`;
   }
	liqPopIdent();	
   return $shapes;
}
global proc string xxu_getShape( string $xform )
{
	liqPushIdent();
	liqlog("xxu_getShape("+$xform+")");

	string $shapes[];
	$shapes = xxu_getShapes($xform);
	
	liqPopIdent();	
	return $shapes[0];
}
//
global proc string xxu_getTransform( string $shape )
{
	liqPushIdent();
	liqlog("xxu_getTransform("+$shape+")");

   string $transform = "";

   if ( "transform" != `nodeType $shape` )
   // If given node is already a transform, just pass on through
   {
      string $parents[] = `listRelatives -fullPath -parent $shape`;
      $transform = $parents[0];
   }

	liqPopIdent();	
   return $transform;
}
// assert window 0
global proc int liqAssert0(string $msg )
{
	string $ret= `confirmDialog -message $msg`;
	if($ret=="Confirm"){
		return 1;
	}else if($ret=="dismiss"){
		return 0;
	}else{
		error ("liqAssert("+$msg+") return unkown value:"+$ret);
	}
}
// assert window 1
global proc int liqAssert1(string $title, string $msg, string $bYes )
{
	liqPushIdent();
	liqlog("liqAssert1("+$title+","+$msg+","+$bYes+")");

	string $ret= `confirmDialog 
				-title $title 
				-message $msg
				-button $bYes 
				//-defaultButton $bYes
				//-cancelButton  "liqAssert_dismiss" 
				-dismissString "liqAssert_dismiss"`;
	if($ret==$bYes){
		liqPopIdent();
		return 1;
	}else if($ret=="liqAssert_dismiss"){
		liqPopIdent();
		return 0;
	}else{
		error ("liqAssert("+$msg+") return unkown value:"+$ret);
	}
	liqPopIdent();
}
// assert window 2
global proc int liqAssert2(string $title, string $msg, string $bYes, string $bNo )
{
	liqPushIdent();
	liqlog("liqAssert2("+$title+","+$msg+","+$bYes+","+$bNo+")");

	string $ret= `confirmDialog 
				-title $title 
				-message $msg
				-button $bYes 
				-button $bNo 
				-defaultButton $bYes
				-cancelButton $bNo 
				-dismissString $bNo`;
	if($ret==$bYes){
		liqPopIdent();
		return 1;
	}else if($ret==$bNo){
		liqPopIdent();
		return 0;
	}else{
		error ("liqAssert("+$msg+") return unkown value:"+$ret);
	}
	liqPopIdent();
}

// myDeleteAttr() always lead a crash on my machine :(
global proc myDeleteAttr(string $node, string $attr, int $loop)
{
	liqPushIdent();
	liqlog("myDeleteAttr("+$node+","+$attr+","+$loop+")");

	string $plug = $node+"."+$attr;

	liqlog("before  renameAttr "+$plug+" \"TO_BE_DELETED\")");
	if ( catch( `renameAttr $plug "TO_BE_DELETED"` ) ){
		liqError("renameAttr "+$plug+" \"TO_BE_DELETED\")");
	}

	//NOTE: without this for-loop, maya may lead to a crash.
	for($i=0; $i<$loop; $i++){ print("+");}print("\n");

	liqlog("before  deleteAttr \""+$node+".TO_BE_DELETED\"");
	if ( catch( `deleteAttr ($node+".TO_BE_DELETED")` ) ){
		liqError("deleteAttr \""+$node+".TO_BE_DELETED\"");
	}
	
	liqPopIdent();
}
// e.g. getChildren("phong1", "color")
// Result: colorR colorG colorB
global proc string[] getChildren(string $node, string $plug)
{
	liqPushIdent();
	liqlog("getChildren("+$node+","+$plug+")");

	string $child[] = `listAttr -multi ($node+"."+$plug)`;
	string $item[] = {$plug};
	$child = stringArrayRemove($item, $child);
	
	liqPopIdent();
	return $child;
}
//
global proc int isSubRendererLoaded(string $renderer)
{
	liqPushIdent();
	liqlog("isSubRendererLoaded("+$renderer+")");

	int $ret = `pluginInfo -q -loaded -name $renderer`;

	liqPopIdent();
	return $ret;
}
//
global proc int isRendererValid()
{
	liqPushIdent();
	liqlog("isRendererValid()");

	string $rnd = liqGetSubRendererName();
	int $ret = isSubRendererLoaded($rnd);

	liqPopIdent();
	return $ret;
}
//
global proc string getValidRenderer()
{
	liqPushIdent();
	liqlog("getValidRenderer()");

	string $rnd = liqGetSubRendererName();

	if( isSubRendererLoaded($rnd) ){
		liqPopIdent();
		return $rnd;
	}else{
		liqError("renderer ["+$rnd+"] is not loaded.");
		liqPopIdent();
		return "";
	}

	liqPopIdent();
}
//
global proc int isCurrentSubRenderer(string $renderer)
{
	liqPushIdent();
	liqlog("isCurrentSubRenderer("+$renderer+")");

	if( !`objExists liquidGlobals` )
		return 0;

	string $currentRenderer = liqGetSubRendererName();
	int $ret = ($currentRenderer == $renderer);

	liqPopIdent();
	return $ret;
}
//
global proc liqDeleteAttr(string $node, string $plug)
{
	liqPushIdent();
	liqlog("liqDeleteAttr("+$node+","+$plug+")");

	if ( `attributeQuery -node $node -ex $plug` ) 
	{
		// philippe: this is a fix to deal with a bug with compound attributes
		renameAttr ( $node + "."+$plug ) "TO_BE_DELETED";
		deleteAttr ( $node + ".TO_BE_DELETED" );
	}
	liqPopIdent();
}
//-----------------------------------------------------------------
//usage: editorTemplate -callCustom "AEliqShaderNew" "AEliqShaderReplace" $plugName;
global proc AEliqShaderNew(string $nodeDotPlug)
{
	liqPushIdent();
	liqlog("AEliqShaderNew("+$nodeDotPlug+")");
		
	string $node;
	string $plug;
	string $buffer[];
	tokenize($nodeDotPlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";
	$plug = (size($buffer) > 1) ? $buffer[1] : "";

	string $plugCtrl = $plug + "Ctrl";
	string $label = $plug;

	attrNavigationControlGrp -label $label $plugCtrl;

	AEliqShaderReplace($nodeDotPlug);

	liqPopIdent();
}
//usage: editorTemplate -callCustom "AEliqShaderNew" "AEliqShaderReplace" $plugName;
global proc AEliqShaderReplace(string $nodeDotPlug)
{
	liqPushIdent();
	liqlog("AEliqShaderReplace("+$nodeDotPlug+")");

	string $plug;
	string $buffer[];
	tokenize($nodeDotPlug, ".", $buffer);
	$plug = (size($buffer) > 1) ? $buffer[1] : "";

	string $plugCtrl = $plug + "Ctrl";

	attrNavigationControlGrp -e -at $nodeDotPlug $plugCtrl;

	liqPopIdent();
}
//
global proc string[] LRP_getAllRenderPasses()
{
  string $render_passes[] = `ls -type (getValidRenderer()+"Globals")`;

  return $render_passes;
}