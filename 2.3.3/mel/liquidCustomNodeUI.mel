source xxliquidutility.mel;
source AEliquidCamera.mel;
source AEliquidInstanceFlags.mel;
source AEliquidLightTemplate.mel;
source AEliquidSubdivisionSurfaceShape.mel;

//
global proc liquidAETemplate_pointLight( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_pointLight("+$node+")");

	//string $renderer[] = liquidGatherValidSubRenderers();
	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_pointLight_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liquidAETemplate_areaLight( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_areaLight("+$node+")");

	//string $renderer[] = liquidGatherValidSubRenderers();
	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_areaLight_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liquidAETemplate_directionalLight( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_directionalLight("+$node+")");

	//string $renderer[] = liquidGatherValidSubRenderers();
	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_directionalLight_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liquidAETemplate_spotLight( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_spotLight("+$node+")");

	//string $renderer[] = liquidGatherValidSubRenderers();
	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_spotLight_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liquidAETemplate_volumeLight( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_volumeLight("+$node+")");

	//string $renderer[] = liquidGatherValidSubRenderers();
	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_volumeLight_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liquidAETemplate_transform( string $node )
{
  liqPushIdent();
  liqAElog("liquidAETemplate_transform("+$node+")");

	string $renderer[] = liquidGatherLoadedSubRenderers();
	for($vrnd in $renderer)
	{
		string $cmd;
		$cmd = "liquidAETemplate_transform_"+$vrnd+"(\""+$node+"\")";
		eval $cmd;
	}

  liqPopIdent();
}
//
global proc liqAETemplateCustomContentCallback(string $nodeName)
{
	liqPushIdent();
	liqlog("liqAETemplateCustomContentCallback("+$nodeName+")");
	
	//editorTemplate -beginScrollLayout;
	editorTemplate -beginLayout ("Liquid") -collapse 1;

		// include the correct code based on the node type
		string $type = `nodeType $nodeName`;
        
		switch ($type)
		{
			case "pointLight":
				liquidAETemplate_pointLight($nodeName);
				break;
			case "areaLight":
				liquidAETemplate_areaLight($nodeName);
				break;
			case "directionalLight":
				liquidAETemplate_directionalLight($nodeName);
				break;
			case "spotLight":
				liquidAETemplate_spotLight($nodeName);
				break;
			case "volumeLight":
				liquidAETemplate_volumeLight($nodeName);
				break;
			//case "file":
			//    AEmentalrayFile $nodeName;
			//    break;
			//case "anisotropic":
			//case "blinn":
			//case "lambert":
			//case "oceanShader":
			//case "hairTubeShader":
			//case "phong":
			//case "phongE":
			//case "rampShader":
			//case "useBackground":
			//case "layeredShader":
			//case "oceanShader":
			//case "shadingMap":
			//case "surfaceShader":
			//    AEmentalrayPhotonAttrs $nodeName;
			//    break;
			//case "shadingEngine":
			//    AEmentalrayMaterial $nodeName;
			//    break;
			case "camera":
				AEliquidCamera $nodeName;
				break;
			case "transform":
				liquidAETemplate_transform($nodeName);
				break;
			//case "mesh":
			//case "nurbsSurface":
			//case "fluidShape":
			//case "hairSystem":
			//case "nParticle":
			//case "particle":
			//case "FurFeedback":
			//    AEmentalrayRenderStats $nodeName;
			//    break;
			case "subdiv":
				AEliquidSubdivisionSurfaceShape $nodeName;
				break;
	        //case "renderLayer":
	        //    AEmentalrayRenderLayer $nodeName;
	        //    break;
	        //case "FurGlobals":
	        //    AEmentalrayFur $nodeName;
	        //    break;
	        //case "FurDescription":
	        //    AEmentalrayFurDescription $nodeName;
	        //    break;
			//case "pfxHair":
			//	AEmentalrayPfxHair $nodeName;
			//	break;
			default:
				liqlog($nodeName+"["+$type+"] is not supported.");
		}
	editorTemplate -endLayout;//AECallbacksTest
	//editorTemplate -endScrollLayout;

	liqPopIdent();	
}