#include <place2dTexture.h>
//shader name: place2dTexture2
void place2dTexture2 (
 output float outUV[];
)
{
  float repeatUV[2] = { 4, 4 };
 repeatUV[ 0 ] = 4;
 repeatUV[ 1 ] = 4;
 extern float s, t;
 outUV[ 0 ] = mod( s * repeatUV[ 0 ], 1 );
 outUV[ 1 ] = mod( t * repeatUV[ 1 ], 1 );
}

//shader name: checker1
void checker1 (
 float uvCoord[];
 output vector outColor;
)
{
  float color1R = float 1;
  float color1G = float 1;
  float color1B = float 1;
 vector color1 = vector ( color1R, color1G, color1B );
  float color2R = float 0;
  float color2G = float 0;
  float color2B = float 0;
 vector color2 = vector ( color2R, color2G, color2B );
//checker1.uvCoord <-- place2dTexture2.outUV
 float ss = uvCoord[0];
 float tt = uvCoord[1];
 if( floor( ss * 2 ) == floor( tt * 2 ) )
 {
  outColor = color1;
 }else{
  outColor = color2;
 }
}

//shader name: lambert2
void lambert2 (
 vector inColor;
)
{
//lambert2.color <-- checker1.outColor
  vector transparency = vector (0,0,0);
  vector ambientColor = vector (0,0,0);
  vector incandescence = vector (0,0,0);
  float diffusion = float 0.8;
  vector outColor = vector (0,0,0);
  vector outTransparency = vector (0,0,0);
 extern normal N;
 normal Nn = normalize( N );
 outTransparency = transparency;
 Oi = Os * color ( 1 - outTransparency );
 outColor = incandescence +
            ( inColor * ( diffusion * 
                          vector diffuse( Nn ) +
                          ambientColor ) );
 Ci = Cs * Oi * color outColor;
}

//surface shader name: lambert2
surface lambert2()
{
 float place2dTexture2_outUV[2];
 vector checker1_outColor;

 //place2dTexture2
 place2dTexture2(place2dTexture2_outUV);
//input: 
//output:place2dTexture2_outUV,

 //checker1
 checker1(place2dTexture2_outUV, checker1_outColor);
//input: place2dTexture2_outUV,
//output:checker1_outColor,

 //lambert2
 lambert2(checker1_outColor);
//input: checker1_outColor,
//output:

}
